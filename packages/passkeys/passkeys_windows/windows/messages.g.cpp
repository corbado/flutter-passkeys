// Autogenerated from Pigeon (v11.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#undef _HAS_EXCEPTIONS

#include "messages.g.h"

#include <flutter/basic_message_channel.h>
#include <flutter/binary_messenger.h>
#include <flutter/encodable_value.h>
#include <flutter/standard_message_codec.h>

#include <map>
#include <optional>
#include <string>

namespace passkeys_windows {
using flutter::BasicMessageChannel;
using flutter::CustomEncodableValue;
using flutter::EncodableList;
using flutter::EncodableMap;
using flutter::EncodableValue;

// RelyingParty

RelyingParty::RelyingParty(
  const std::string& name,
  const std::string& id)
 : name_(name),
    id_(id) {}

const std::string& RelyingParty::name() const {
  return name_;
}

void RelyingParty::set_name(std::string_view value_arg) {
  name_ = value_arg;
}


const std::string& RelyingParty::id() const {
  return id_;
}

void RelyingParty::set_id(std::string_view value_arg) {
  id_ = value_arg;
}


EncodableList RelyingParty::ToEncodableList() const {
  EncodableList list;
  list.reserve(2);
  list.push_back(EncodableValue(name_));
  list.push_back(EncodableValue(id_));
  return list;
}

RelyingParty RelyingParty::FromEncodableList(const EncodableList& list) {
  RelyingParty decoded(
    std::get<std::string>(list[0]),
    std::get<std::string>(list[1]));
  return decoded;
}

// PubKeyCredParam

PubKeyCredParam::PubKeyCredParam(
  const std::string& type,
  int64_t alg)
 : type_(type),
    alg_(alg) {}

const std::string& PubKeyCredParam::type() const {
  return type_;
}

void PubKeyCredParam::set_type(std::string_view value_arg) {
  type_ = value_arg;
}


int64_t PubKeyCredParam::alg() const {
  return alg_;
}

void PubKeyCredParam::set_alg(int64_t value_arg) {
  alg_ = value_arg;
}


EncodableList PubKeyCredParam::ToEncodableList() const {
  EncodableList list;
  list.reserve(2);
  list.push_back(EncodableValue(type_));
  list.push_back(EncodableValue(alg_));
  return list;
}

PubKeyCredParam PubKeyCredParam::FromEncodableList(const EncodableList& list) {
  PubKeyCredParam decoded(
    std::get<std::string>(list[0]),
    list[1].LongValue());
  return decoded;
}

// User

User::User(
  const std::string& display_name,
  const std::string& name,
  const std::string& id)
 : display_name_(display_name),
    name_(name),
    id_(id) {}

User::User(
  const std::string& display_name,
  const std::string& name,
  const std::string& id,
  const std::string* icon)
 : display_name_(display_name),
    name_(name),
    id_(id),
    icon_(icon ? std::optional<std::string>(*icon) : std::nullopt) {}

const std::string& User::display_name() const {
  return display_name_;
}

void User::set_display_name(std::string_view value_arg) {
  display_name_ = value_arg;
}


const std::string& User::name() const {
  return name_;
}

void User::set_name(std::string_view value_arg) {
  name_ = value_arg;
}


const std::string& User::id() const {
  return id_;
}

void User::set_id(std::string_view value_arg) {
  id_ = value_arg;
}


const std::string* User::icon() const {
  return icon_ ? &(*icon_) : nullptr;
}

void User::set_icon(const std::string_view* value_arg) {
  icon_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void User::set_icon(std::string_view value_arg) {
  icon_ = value_arg;
}


EncodableList User::ToEncodableList() const {
  EncodableList list;
  list.reserve(4);
  list.push_back(EncodableValue(display_name_));
  list.push_back(EncodableValue(name_));
  list.push_back(EncodableValue(id_));
  list.push_back(icon_ ? EncodableValue(*icon_) : EncodableValue());
  return list;
}

User User::FromEncodableList(const EncodableList& list) {
  User decoded(
    std::get<std::string>(list[0]),
    std::get<std::string>(list[1]),
    std::get<std::string>(list[2]));
  auto& encodable_icon = list[3];
  if (!encodable_icon.IsNull()) {
    decoded.set_icon(std::get<std::string>(encodable_icon));
  }
  return decoded;
}

// AllowCredential

AllowCredential::AllowCredential(
  const std::string& type,
  const std::string& id,
  const EncodableList& transports)
 : type_(type),
    id_(id),
    transports_(transports) {}

const std::string& AllowCredential::type() const {
  return type_;
}

void AllowCredential::set_type(std::string_view value_arg) {
  type_ = value_arg;
}


const std::string& AllowCredential::id() const {
  return id_;
}

void AllowCredential::set_id(std::string_view value_arg) {
  id_ = value_arg;
}


const EncodableList& AllowCredential::transports() const {
  return transports_;
}

void AllowCredential::set_transports(const EncodableList& value_arg) {
  transports_ = value_arg;
}


EncodableList AllowCredential::ToEncodableList() const {
  EncodableList list;
  list.reserve(3);
  list.push_back(EncodableValue(type_));
  list.push_back(EncodableValue(id_));
  list.push_back(EncodableValue(transports_));
  return list;
}

AllowCredential AllowCredential::FromEncodableList(const EncodableList& list) {
  AllowCredential decoded(
    std::get<std::string>(list[0]),
    std::get<std::string>(list[1]),
    std::get<EncodableList>(list[2]));
  return decoded;
}

// ExcludeCredential

ExcludeCredential::ExcludeCredential(
  const std::string& type,
  const std::string& id)
 : type_(type),
    id_(id) {}

const std::string& ExcludeCredential::type() const {
  return type_;
}

void ExcludeCredential::set_type(std::string_view value_arg) {
  type_ = value_arg;
}


const std::string& ExcludeCredential::id() const {
  return id_;
}

void ExcludeCredential::set_id(std::string_view value_arg) {
  id_ = value_arg;
}


EncodableList ExcludeCredential::ToEncodableList() const {
  EncodableList list;
  list.reserve(2);
  list.push_back(EncodableValue(type_));
  list.push_back(EncodableValue(id_));
  return list;
}

ExcludeCredential ExcludeCredential::FromEncodableList(const EncodableList& list) {
  ExcludeCredential decoded(
    std::get<std::string>(list[0]),
    std::get<std::string>(list[1]));
  return decoded;
}

// AuthenticatorSelection

AuthenticatorSelection::AuthenticatorSelection(
  bool require_resident_key,
  const std::string& resident_key,
  const std::string& user_verification)
 : require_resident_key_(require_resident_key),
    resident_key_(resident_key),
    user_verification_(user_verification) {}

AuthenticatorSelection::AuthenticatorSelection(
  const std::string* authenticator_attachment,
  bool require_resident_key,
  const std::string& resident_key,
  const std::string& user_verification)
 : authenticator_attachment_(authenticator_attachment ? std::optional<std::string>(*authenticator_attachment) : std::nullopt),
    require_resident_key_(require_resident_key),
    resident_key_(resident_key),
    user_verification_(user_verification) {}

const std::string* AuthenticatorSelection::authenticator_attachment() const {
  return authenticator_attachment_ ? &(*authenticator_attachment_) : nullptr;
}

void AuthenticatorSelection::set_authenticator_attachment(const std::string_view* value_arg) {
  authenticator_attachment_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void AuthenticatorSelection::set_authenticator_attachment(std::string_view value_arg) {
  authenticator_attachment_ = value_arg;
}


bool AuthenticatorSelection::require_resident_key() const {
  return require_resident_key_;
}

void AuthenticatorSelection::set_require_resident_key(bool value_arg) {
  require_resident_key_ = value_arg;
}


const std::string& AuthenticatorSelection::resident_key() const {
  return resident_key_;
}

void AuthenticatorSelection::set_resident_key(std::string_view value_arg) {
  resident_key_ = value_arg;
}


const std::string& AuthenticatorSelection::user_verification() const {
  return user_verification_;
}

void AuthenticatorSelection::set_user_verification(std::string_view value_arg) {
  user_verification_ = value_arg;
}


EncodableList AuthenticatorSelection::ToEncodableList() const {
  EncodableList list;
  list.reserve(4);
  list.push_back(authenticator_attachment_ ? EncodableValue(*authenticator_attachment_) : EncodableValue());
  list.push_back(EncodableValue(require_resident_key_));
  list.push_back(EncodableValue(resident_key_));
  list.push_back(EncodableValue(user_verification_));
  return list;
}

AuthenticatorSelection AuthenticatorSelection::FromEncodableList(const EncodableList& list) {
  AuthenticatorSelection decoded(
    std::get<bool>(list[1]),
    std::get<std::string>(list[2]),
    std::get<std::string>(list[3]));
  auto& encodable_authenticator_attachment = list[0];
  if (!encodable_authenticator_attachment.IsNull()) {
    decoded.set_authenticator_attachment(std::get<std::string>(encodable_authenticator_attachment));
  }
  return decoded;
}

// RegisterResponse

RegisterResponse::RegisterResponse(
  const std::string& id,
  const std::string& raw_id,
  const std::string& client_data_j_s_o_n,
  const std::string& attestation_object,
  const EncodableList& transports)
 : id_(id),
    raw_id_(raw_id),
    client_data_j_s_o_n_(client_data_j_s_o_n),
    attestation_object_(attestation_object),
    transports_(transports) {}

const std::string& RegisterResponse::id() const {
  return id_;
}

void RegisterResponse::set_id(std::string_view value_arg) {
  id_ = value_arg;
}


const std::string& RegisterResponse::raw_id() const {
  return raw_id_;
}

void RegisterResponse::set_raw_id(std::string_view value_arg) {
  raw_id_ = value_arg;
}


const std::string& RegisterResponse::client_data_j_s_o_n() const {
  return client_data_j_s_o_n_;
}

void RegisterResponse::set_client_data_j_s_o_n(std::string_view value_arg) {
  client_data_j_s_o_n_ = value_arg;
}


const std::string& RegisterResponse::attestation_object() const {
  return attestation_object_;
}

void RegisterResponse::set_attestation_object(std::string_view value_arg) {
  attestation_object_ = value_arg;
}


const EncodableList& RegisterResponse::transports() const {
  return transports_;
}

void RegisterResponse::set_transports(const EncodableList& value_arg) {
  transports_ = value_arg;
}


EncodableList RegisterResponse::ToEncodableList() const {
  EncodableList list;
  list.reserve(5);
  list.push_back(EncodableValue(id_));
  list.push_back(EncodableValue(raw_id_));
  list.push_back(EncodableValue(client_data_j_s_o_n_));
  list.push_back(EncodableValue(attestation_object_));
  list.push_back(EncodableValue(transports_));
  return list;
}

RegisterResponse RegisterResponse::FromEncodableList(const EncodableList& list) {
  RegisterResponse decoded(
    std::get<std::string>(list[0]),
    std::get<std::string>(list[1]),
    std::get<std::string>(list[2]),
    std::get<std::string>(list[3]),
    std::get<EncodableList>(list[4]));
  return decoded;
}

// AuthenticateResponse

AuthenticateResponse::AuthenticateResponse(
  const std::string& id,
  const std::string& raw_id,
  const std::string& client_data_j_s_o_n,
  const std::string& authenticator_data,
  const std::string& signature,
  const std::string& user_handle)
 : id_(id),
    raw_id_(raw_id),
    client_data_j_s_o_n_(client_data_j_s_o_n),
    authenticator_data_(authenticator_data),
    signature_(signature),
    user_handle_(user_handle) {}

const std::string& AuthenticateResponse::id() const {
  return id_;
}

void AuthenticateResponse::set_id(std::string_view value_arg) {
  id_ = value_arg;
}


const std::string& AuthenticateResponse::raw_id() const {
  return raw_id_;
}

void AuthenticateResponse::set_raw_id(std::string_view value_arg) {
  raw_id_ = value_arg;
}


const std::string& AuthenticateResponse::client_data_j_s_o_n() const {
  return client_data_j_s_o_n_;
}

void AuthenticateResponse::set_client_data_j_s_o_n(std::string_view value_arg) {
  client_data_j_s_o_n_ = value_arg;
}


const std::string& AuthenticateResponse::authenticator_data() const {
  return authenticator_data_;
}

void AuthenticateResponse::set_authenticator_data(std::string_view value_arg) {
  authenticator_data_ = value_arg;
}


const std::string& AuthenticateResponse::signature() const {
  return signature_;
}

void AuthenticateResponse::set_signature(std::string_view value_arg) {
  signature_ = value_arg;
}


const std::string& AuthenticateResponse::user_handle() const {
  return user_handle_;
}

void AuthenticateResponse::set_user_handle(std::string_view value_arg) {
  user_handle_ = value_arg;
}


EncodableList AuthenticateResponse::ToEncodableList() const {
  EncodableList list;
  list.reserve(6);
  list.push_back(EncodableValue(id_));
  list.push_back(EncodableValue(raw_id_));
  list.push_back(EncodableValue(client_data_j_s_o_n_));
  list.push_back(EncodableValue(authenticator_data_));
  list.push_back(EncodableValue(signature_));
  list.push_back(EncodableValue(user_handle_));
  return list;
}

AuthenticateResponse AuthenticateResponse::FromEncodableList(const EncodableList& list) {
  AuthenticateResponse decoded(
    std::get<std::string>(list[0]),
    std::get<std::string>(list[1]),
    std::get<std::string>(list[2]),
    std::get<std::string>(list[3]),
    std::get<std::string>(list[4]),
    std::get<std::string>(list[5]));
  return decoded;
}


PasskeysApiCodecSerializer::PasskeysApiCodecSerializer() {}

EncodableValue PasskeysApiCodecSerializer::ReadValueOfType(
  uint8_t type,
  flutter::ByteStreamReader* stream) const {
  switch (type) {
    case 128:
      return CustomEncodableValue(AllowCredential::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 129:
      return CustomEncodableValue(AuthenticateResponse::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 130:
      return CustomEncodableValue(AuthenticatorSelection::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 131:
      return CustomEncodableValue(ExcludeCredential::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 132:
      return CustomEncodableValue(PubKeyCredParam::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 133:
      return CustomEncodableValue(RegisterResponse::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 134:
      return CustomEncodableValue(RelyingParty::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 135:
      return CustomEncodableValue(User::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    default:
      return flutter::StandardCodecSerializer::ReadValueOfType(type, stream);
  }
}

void PasskeysApiCodecSerializer::WriteValue(
  const EncodableValue& value,
  flutter::ByteStreamWriter* stream) const {
  if (const CustomEncodableValue* custom_value = std::get_if<CustomEncodableValue>(&value)) {
    if (custom_value->type() == typeid(AllowCredential)) {
      stream->WriteByte(128);
      WriteValue(EncodableValue(std::any_cast<AllowCredential>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(AuthenticateResponse)) {
      stream->WriteByte(129);
      WriteValue(EncodableValue(std::any_cast<AuthenticateResponse>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(AuthenticatorSelection)) {
      stream->WriteByte(130);
      WriteValue(EncodableValue(std::any_cast<AuthenticatorSelection>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(ExcludeCredential)) {
      stream->WriteByte(131);
      WriteValue(EncodableValue(std::any_cast<ExcludeCredential>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(PubKeyCredParam)) {
      stream->WriteByte(132);
      WriteValue(EncodableValue(std::any_cast<PubKeyCredParam>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RegisterResponse)) {
      stream->WriteByte(133);
      WriteValue(EncodableValue(std::any_cast<RegisterResponse>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RelyingParty)) {
      stream->WriteByte(134);
      WriteValue(EncodableValue(std::any_cast<RelyingParty>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(User)) {
      stream->WriteByte(135);
      WriteValue(EncodableValue(std::any_cast<User>(*custom_value).ToEncodableList()), stream);
      return;
    }
  }
  flutter::StandardCodecSerializer::WriteValue(value, stream);
}

/// The codec used by PasskeysApi.
const flutter::StandardMessageCodec& PasskeysApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(&PasskeysApiCodecSerializer::GetInstance());
}

// Sets up an instance of `PasskeysApi` to handle messages through the `binary_messenger`.
void PasskeysApi::SetUp(
  flutter::BinaryMessenger* binary_messenger,
  PasskeysApi* api) {
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.passkeys_windows.PasskeysApi.canAuthenticate", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->CanAuthenticate([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.passkeys_windows.PasskeysApi.hasPasskeySupport", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->HasPasskeySupport([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.passkeys_windows.PasskeysApi.register", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_challenge_arg = args.at(0);
          if (encodable_challenge_arg.IsNull()) {
            reply(WrapError("challenge_arg unexpectedly null."));
            return;
          }
          const auto& challenge_arg = std::get<std::string>(encodable_challenge_arg);
          const auto& encodable_relying_party_arg = args.at(1);
          if (encodable_relying_party_arg.IsNull()) {
            reply(WrapError("relying_party_arg unexpectedly null."));
            return;
          }
          const auto& relying_party_arg = std::any_cast<const RelyingParty&>(std::get<CustomEncodableValue>(encodable_relying_party_arg));
          const auto& encodable_user_arg = args.at(2);
          if (encodable_user_arg.IsNull()) {
            reply(WrapError("user_arg unexpectedly null."));
            return;
          }
          const auto& user_arg = std::any_cast<const User&>(std::get<CustomEncodableValue>(encodable_user_arg));
          const auto& encodable_authenticator_selection_arg = args.at(3);
          const auto* authenticator_selection_arg = &(std::any_cast<const AuthenticatorSelection&>(std::get<CustomEncodableValue>(encodable_authenticator_selection_arg)));
          const auto& encodable_pub_key_cred_params_arg = args.at(4);
          const auto* pub_key_cred_params_arg = std::get_if<EncodableList>(&encodable_pub_key_cred_params_arg);
          const auto& encodable_timeout_arg = args.at(5);
          const int64_t timeout_arg_value = encodable_timeout_arg.IsNull() ? 0 : encodable_timeout_arg.LongValue();
          const auto* timeout_arg = encodable_timeout_arg.IsNull() ? nullptr : &timeout_arg_value;
          const auto& encodable_attestation_arg = args.at(6);
          const auto* attestation_arg = std::get_if<std::string>(&encodable_attestation_arg);
          const auto& encodable_exclude_credentials_arg = args.at(7);
          if (encodable_exclude_credentials_arg.IsNull()) {
            reply(WrapError("exclude_credentials_arg unexpectedly null."));
            return;
          }
          const auto& exclude_credentials_arg = std::get<EncodableList>(encodable_exclude_credentials_arg);
          api->Register(challenge_arg, relying_party_arg, user_arg, authenticator_selection_arg, pub_key_cred_params_arg, timeout_arg, attestation_arg, exclude_credentials_arg, [reply](ErrorOr<RegisterResponse>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.passkeys_windows.PasskeysApi.authenticate", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_relying_party_id_arg = args.at(0);
          if (encodable_relying_party_id_arg.IsNull()) {
            reply(WrapError("relying_party_id_arg unexpectedly null."));
            return;
          }
          const auto& relying_party_id_arg = std::get<std::string>(encodable_relying_party_id_arg);
          const auto& encodable_challenge_arg = args.at(1);
          if (encodable_challenge_arg.IsNull()) {
            reply(WrapError("challenge_arg unexpectedly null."));
            return;
          }
          const auto& challenge_arg = std::get<std::string>(encodable_challenge_arg);
          const auto& encodable_timeout_arg = args.at(2);
          const int64_t timeout_arg_value = encodable_timeout_arg.IsNull() ? 0 : encodable_timeout_arg.LongValue();
          const auto* timeout_arg = encodable_timeout_arg.IsNull() ? nullptr : &timeout_arg_value;
          const auto& encodable_user_verification_arg = args.at(3);
          const auto* user_verification_arg = std::get_if<std::string>(&encodable_user_verification_arg);
          const auto& encodable_allow_credentials_arg = args.at(4);
          const auto* allow_credentials_arg = std::get_if<EncodableList>(&encodable_allow_credentials_arg);
          const auto& encodable_prefer_immediately_available_credentials_arg = args.at(5);
          const auto* prefer_immediately_available_credentials_arg = std::get_if<bool>(&encodable_prefer_immediately_available_credentials_arg);
          api->Authenticate(relying_party_id_arg, challenge_arg, timeout_arg, user_verification_arg, allow_credentials_arg, prefer_immediately_available_credentials_arg, [reply](ErrorOr<AuthenticateResponse>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.passkeys_windows.PasskeysApi.cancelCurrentAuthenticatorOperation", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->CancelCurrentAuthenticatorOperation([reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
}

EncodableValue PasskeysApi::WrapError(std::string_view error_message) {
  return EncodableValue(EncodableList{
    EncodableValue(std::string(error_message)),
    EncodableValue("Error"),
    EncodableValue()
  });
}

EncodableValue PasskeysApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{
    EncodableValue(error.code()),
    EncodableValue(error.message()),
    error.details()
  });
}

}  // namespace passkeys_windows
