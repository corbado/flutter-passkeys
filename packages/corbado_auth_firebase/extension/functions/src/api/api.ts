/* tslint:disable */
/* eslint-disable */
/**
 * Corbado Frontend API
 * Overview of all Corbado Frontend API calls to implement passwordless authentication.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@corbado.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AppleAppSiteAssociationRsp
 */
export interface AppleAppSiteAssociationRsp {
    /**
     * 
     * @type {AppleAppSiteAssociationRspApplinks}
     * @memberof AppleAppSiteAssociationRsp
     */
    'applinks': AppleAppSiteAssociationRspApplinks;
    /**
     * 
     * @type {AppleAppSiteAssociationRspWebcredentials}
     * @memberof AppleAppSiteAssociationRsp
     */
    'webcredentials': AppleAppSiteAssociationRspWebcredentials;
    /**
     * 
     * @type {AppleAppSiteAssociationRspWebcredentials}
     * @memberof AppleAppSiteAssociationRsp
     */
    'appclips': AppleAppSiteAssociationRspWebcredentials;
}
/**
 * 
 * @export
 * @interface AppleAppSiteAssociationRspApplinks
 */
export interface AppleAppSiteAssociationRspApplinks {
    /**
     * 
     * @type {Array<AppleAppSiteAssociationRspApplinksDetailsInner>}
     * @memberof AppleAppSiteAssociationRspApplinks
     */
    'details': Array<AppleAppSiteAssociationRspApplinksDetailsInner>;
}
/**
 * 
 * @export
 * @interface AppleAppSiteAssociationRspApplinksDetailsInner
 */
export interface AppleAppSiteAssociationRspApplinksDetailsInner {
    /**
     * 
     * @type {string}
     * @memberof AppleAppSiteAssociationRspApplinksDetailsInner
     */
    'appID': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AppleAppSiteAssociationRspApplinksDetailsInner
     */
    'paths': Array<string>;
}
/**
 * 
 * @export
 * @interface AppleAppSiteAssociationRspWebcredentials
 */
export interface AppleAppSiteAssociationRspWebcredentials {
    /**
     * 
     * @type {Array<string>}
     * @memberof AppleAppSiteAssociationRspWebcredentials
     */
    'apps': Array<string>;
}
/**
 * 
 * @export
 * @interface AssetLink
 */
export interface AssetLink {
    /**
     * 
     * @type {Array<string>}
     * @memberof AssetLink
     */
    'relation': Array<string>;
    /**
     * 
     * @type {AssetLinkTarget}
     * @memberof AssetLink
     */
    'target': AssetLinkTarget;
}
/**
 * 
 * @export
 * @interface AssetLinkTarget
 */
export interface AssetLinkTarget {
    /**
     * 
     * @type {string}
     * @memberof AssetLinkTarget
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof AssetLinkTarget
     */
    'package_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetLinkTarget
     */
    'site'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AssetLinkTarget
     */
    'sha256_cert_fingerprints'?: Array<string>;
}
/**
 * Authentication methods
 * @export
 * @enum {string}
 */

export const AuthMethod = {
    Email: 'email',
    PhoneNumber: 'phone_number',
    Webauthn: 'webauthn',
    Password: 'password'
} as const;

export type AuthMethod = typeof AuthMethod[keyof typeof AuthMethod];


/**
 * 
 * @export
 * @interface AuthMethodsListReq
 */
export interface AuthMethodsListReq {
    /**
     * Users login name
     * @type {string}
     * @memberof AuthMethodsListReq
     */
    'username': string;
    /**
     * Unique ID of request, you can provide your own while making the request, if not the ID will be randomly generated on server side
     * @type {string}
     * @memberof AuthMethodsListReq
     */
    'requestID'?: string;
}
/**
 * 
 * @export
 * @interface AuthMethodsListRsp
 */
export interface AuthMethodsListRsp {
    /**
     * HTTP status code of operation
     * @type {number}
     * @memberof AuthMethodsListRsp
     */
    'httpStatusCode': number;
    /**
     * 
     * @type {string}
     * @memberof AuthMethodsListRsp
     */
    'message': string;
    /**
     * 
     * @type {RequestData}
     * @memberof AuthMethodsListRsp
     */
    'requestData': RequestData;
    /**
     * Runtime in seconds for this request
     * @type {number}
     * @memberof AuthMethodsListRsp
     */
    'runtime': number;
    /**
     * 
     * @type {AuthMethodsListRspAllOfData}
     * @memberof AuthMethodsListRsp
     */
    'data': AuthMethodsListRspAllOfData;
}
/**
 * 
 * @export
 * @interface AuthMethodsListRspAllOfData
 */
export interface AuthMethodsListRspAllOfData {
    /**
     * 
     * @type {Array<AuthMethod>}
     * @memberof AuthMethodsListRspAllOfData
     */
    'selectedMethods': Array<AuthMethod>;
    /**
     * 
     * @type {Array<AuthMethod>}
     * @memberof AuthMethodsListRspAllOfData
     */
    'possibleMethods': Array<AuthMethod>;
}
/**
 * 
 * @export
 * @interface AuthenticationRsp
 */
export interface AuthenticationRsp {
    /**
     * 
     * @type {string}
     * @memberof AuthenticationRsp
     */
    'redirectURL': string;
    /**
     * Only given when using session v1
     * @type {string}
     * @memberof AuthenticationRsp
     */
    'sessionToken'?: string;
    /**
     * Only given when project environment is dev
     * @type {string}
     * @memberof AuthenticationRsp
     */
    'longSession'?: string;
    /**
     * 
     * @type {ShortSession}
     * @memberof AuthenticationRsp
     */
    'shortSession'?: ShortSession;
    /**
     * 
     * @type {Array<AuthMethod>}
     * @memberof AuthenticationRsp
     */
    'authMethods': Array<AuthMethod>;
}
/**
 * 
 * @export
 * @interface EmailCodeConfirmReq
 */
export interface EmailCodeConfirmReq {
    /**
     * 
     * @type {string}
     * @memberof EmailCodeConfirmReq
     */
    'emailCodeID': string;
    /**
     * 
     * @type {string}
     * @memberof EmailCodeConfirmReq
     */
    'code': string;
    /**
     * Unique ID of request, you can provide your own while making the request, if not the ID will be randomly generated on server side
     * @type {string}
     * @memberof EmailCodeConfirmReq
     */
    'requestID'?: string;
}
/**
 * 
 * @export
 * @interface EmailCodeConfirmRsp
 */
export interface EmailCodeConfirmRsp {
    /**
     * HTTP status code of operation
     * @type {number}
     * @memberof EmailCodeConfirmRsp
     */
    'httpStatusCode': number;
    /**
     * 
     * @type {string}
     * @memberof EmailCodeConfirmRsp
     */
    'message': string;
    /**
     * 
     * @type {RequestData}
     * @memberof EmailCodeConfirmRsp
     */
    'requestData': RequestData;
    /**
     * Runtime in seconds for this request
     * @type {number}
     * @memberof EmailCodeConfirmRsp
     */
    'runtime': number;
    /**
     * 
     * @type {EmailCodeConfirmRspAllOfData}
     * @memberof EmailCodeConfirmRsp
     */
    'data': EmailCodeConfirmRspAllOfData;
}
/**
 * 
 * @export
 * @interface EmailCodeConfirmRspAllOfData
 */
export interface EmailCodeConfirmRspAllOfData {
    /**
     * 
     * @type {string}
     * @memberof EmailCodeConfirmRspAllOfData
     */
    'redirectURL': string;
    /**
     * Only given when using session v1
     * @type {string}
     * @memberof EmailCodeConfirmRspAllOfData
     */
    'sessionToken'?: string;
    /**
     * Only given when project environment is dev
     * @type {string}
     * @memberof EmailCodeConfirmRspAllOfData
     */
    'longSession'?: string;
    /**
     * 
     * @type {ShortSession}
     * @memberof EmailCodeConfirmRspAllOfData
     */
    'shortSession'?: ShortSession;
    /**
     * 
     * @type {Array<AuthMethod>}
     * @memberof EmailCodeConfirmRspAllOfData
     */
    'authMethods': Array<AuthMethod>;
}
/**
 * 
 * @export
 * @interface EmailCodeLoginStartReq
 */
export interface EmailCodeLoginStartReq {
    /**
     * 
     * @type {string}
     * @memberof EmailCodeLoginStartReq
     */
    'username': string;
    /**
     * Unique ID of request, you can provide your own while making the request, if not the ID will be randomly generated on server side
     * @type {string}
     * @memberof EmailCodeLoginStartReq
     */
    'requestID'?: string;
}
/**
 * 
 * @export
 * @interface EmailCodeLoginStartRsp
 */
export interface EmailCodeLoginStartRsp {
    /**
     * HTTP status code of operation
     * @type {number}
     * @memberof EmailCodeLoginStartRsp
     */
    'httpStatusCode': number;
    /**
     * 
     * @type {string}
     * @memberof EmailCodeLoginStartRsp
     */
    'message': string;
    /**
     * 
     * @type {RequestData}
     * @memberof EmailCodeLoginStartRsp
     */
    'requestData': RequestData;
    /**
     * Runtime in seconds for this request
     * @type {number}
     * @memberof EmailCodeLoginStartRsp
     */
    'runtime': number;
    /**
     * 
     * @type {EmailCodeRegisterStartRspAllOfData}
     * @memberof EmailCodeLoginStartRsp
     */
    'data': EmailCodeRegisterStartRspAllOfData;
}
/**
 * 
 * @export
 * @interface EmailCodeRegisterStartReq
 */
export interface EmailCodeRegisterStartReq {
    /**
     * 
     * @type {string}
     * @memberof EmailCodeRegisterStartReq
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCodeRegisterStartReq
     */
    'email': string;
    /**
     * Unique ID of request, you can provide your own while making the request, if not the ID will be randomly generated on server side
     * @type {string}
     * @memberof EmailCodeRegisterStartReq
     */
    'requestID'?: string;
}
/**
 * 
 * @export
 * @interface EmailCodeRegisterStartRsp
 */
export interface EmailCodeRegisterStartRsp {
    /**
     * HTTP status code of operation
     * @type {number}
     * @memberof EmailCodeRegisterStartRsp
     */
    'httpStatusCode': number;
    /**
     * 
     * @type {string}
     * @memberof EmailCodeRegisterStartRsp
     */
    'message': string;
    /**
     * 
     * @type {RequestData}
     * @memberof EmailCodeRegisterStartRsp
     */
    'requestData': RequestData;
    /**
     * Runtime in seconds for this request
     * @type {number}
     * @memberof EmailCodeRegisterStartRsp
     */
    'runtime': number;
    /**
     * 
     * @type {EmailCodeRegisterStartRspAllOfData}
     * @memberof EmailCodeRegisterStartRsp
     */
    'data': EmailCodeRegisterStartRspAllOfData;
}
/**
 * 
 * @export
 * @interface EmailCodeRegisterStartRspAllOfData
 */
export interface EmailCodeRegisterStartRspAllOfData {
    /**
     * 
     * @type {string}
     * @memberof EmailCodeRegisterStartRspAllOfData
     */
    'emailCodeID': string;
}
/**
 * 
 * @export
 * @interface EmailCodeStatusReq
 */
export interface EmailCodeStatusReq {
    /**
     * 
     * @type {string}
     * @memberof EmailCodeStatusReq
     */
    'emailCodeID': string;
    /**
     * Unique ID of request, you can provide your own while making the request, if not the ID will be randomly generated on server side
     * @type {string}
     * @memberof EmailCodeStatusReq
     */
    'requestID'?: string;
}
/**
 * 
 * @export
 * @interface EmailCodeStatusRsp
 */
export interface EmailCodeStatusRsp {
    /**
     * HTTP status code of operation
     * @type {number}
     * @memberof EmailCodeStatusRsp
     */
    'httpStatusCode': number;
    /**
     * 
     * @type {string}
     * @memberof EmailCodeStatusRsp
     */
    'message': string;
    /**
     * 
     * @type {RequestData}
     * @memberof EmailCodeStatusRsp
     */
    'requestData': RequestData;
    /**
     * Runtime in seconds for this request
     * @type {number}
     * @memberof EmailCodeStatusRsp
     */
    'runtime': number;
    /**
     * 
     * @type {AuthenticationRsp}
     * @memberof EmailCodeStatusRsp
     */
    'data': AuthenticationRsp;
}
/**
 * 
 * @export
 * @interface EmailLinkConfirmReq
 */
export interface EmailLinkConfirmReq {
    /**
     * 
     * @type {string}
     * @memberof EmailLinkConfirmReq
     */
    'emailLinkID': string;
    /**
     * 
     * @type {string}
     * @memberof EmailLinkConfirmReq
     */
    'token': string;
    /**
     * Unique ID of request, you can provide your own while making the request, if not the ID will be randomly generated on server side
     * @type {string}
     * @memberof EmailLinkConfirmReq
     */
    'requestID'?: string;
}
/**
 * 
 * @export
 * @interface EmailLinkConfirmRsp
 */
export interface EmailLinkConfirmRsp {
    /**
     * HTTP status code of operation
     * @type {number}
     * @memberof EmailLinkConfirmRsp
     */
    'httpStatusCode': number;
    /**
     * 
     * @type {string}
     * @memberof EmailLinkConfirmRsp
     */
    'message': string;
    /**
     * 
     * @type {RequestData}
     * @memberof EmailLinkConfirmRsp
     */
    'requestData': RequestData;
    /**
     * Runtime in seconds for this request
     * @type {number}
     * @memberof EmailLinkConfirmRsp
     */
    'runtime': number;
    /**
     * 
     * @type {EmailLinkConfirmRspAllOfData}
     * @memberof EmailLinkConfirmRsp
     */
    'data': EmailLinkConfirmRspAllOfData;
}
/**
 * 
 * @export
 * @interface EmailLinkConfirmRspAllOfData
 */
export interface EmailLinkConfirmRspAllOfData {
    /**
     * 
     * @type {string}
     * @memberof EmailLinkConfirmRspAllOfData
     */
    'redirectURL': string;
    /**
     * Only given when using session v1
     * @type {string}
     * @memberof EmailLinkConfirmRspAllOfData
     */
    'sessionToken'?: string;
    /**
     * Only given when project environment is dev
     * @type {string}
     * @memberof EmailLinkConfirmRspAllOfData
     */
    'longSession'?: string;
    /**
     * 
     * @type {ShortSession}
     * @memberof EmailLinkConfirmRspAllOfData
     */
    'shortSession'?: ShortSession;
    /**
     * 
     * @type {Array<AuthMethod>}
     * @memberof EmailLinkConfirmRspAllOfData
     */
    'authMethods': Array<AuthMethod>;
}
/**
 * 
 * @export
 * @interface EmailLinkLoginStartReq
 */
export interface EmailLinkLoginStartReq {
    /**
     * 
     * @type {string}
     * @memberof EmailLinkLoginStartReq
     */
    'username': string;
    /**
     * Unique ID of request, you can provide your own while making the request, if not the ID will be randomly generated on server side
     * @type {string}
     * @memberof EmailLinkLoginStartReq
     */
    'requestID'?: string;
}
/**
 * 
 * @export
 * @interface EmailLinkLoginStartRsp
 */
export interface EmailLinkLoginStartRsp {
    /**
     * HTTP status code of operation
     * @type {number}
     * @memberof EmailLinkLoginStartRsp
     */
    'httpStatusCode': number;
    /**
     * 
     * @type {string}
     * @memberof EmailLinkLoginStartRsp
     */
    'message': string;
    /**
     * 
     * @type {RequestData}
     * @memberof EmailLinkLoginStartRsp
     */
    'requestData': RequestData;
    /**
     * Runtime in seconds for this request
     * @type {number}
     * @memberof EmailLinkLoginStartRsp
     */
    'runtime': number;
    /**
     * 
     * @type {EmailLinkRegisterStartRspAllOfData}
     * @memberof EmailLinkLoginStartRsp
     */
    'data': EmailLinkRegisterStartRspAllOfData;
}
/**
 * 
 * @export
 * @interface EmailLinkRegisterStartReq
 */
export interface EmailLinkRegisterStartReq {
    /**
     * 
     * @type {string}
     * @memberof EmailLinkRegisterStartReq
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailLinkRegisterStartReq
     */
    'email': string;
    /**
     * Unique ID of request, you can provide your own while making the request, if not the ID will be randomly generated on server side
     * @type {string}
     * @memberof EmailLinkRegisterStartReq
     */
    'requestID'?: string;
}
/**
 * 
 * @export
 * @interface EmailLinkRegisterStartRsp
 */
export interface EmailLinkRegisterStartRsp {
    /**
     * HTTP status code of operation
     * @type {number}
     * @memberof EmailLinkRegisterStartRsp
     */
    'httpStatusCode': number;
    /**
     * 
     * @type {string}
     * @memberof EmailLinkRegisterStartRsp
     */
    'message': string;
    /**
     * 
     * @type {RequestData}
     * @memberof EmailLinkRegisterStartRsp
     */
    'requestData': RequestData;
    /**
     * Runtime in seconds for this request
     * @type {number}
     * @memberof EmailLinkRegisterStartRsp
     */
    'runtime': number;
    /**
     * 
     * @type {EmailLinkRegisterStartRspAllOfData}
     * @memberof EmailLinkRegisterStartRsp
     */
    'data': EmailLinkRegisterStartRspAllOfData;
}
/**
 * 
 * @export
 * @interface EmailLinkRegisterStartRspAllOfData
 */
export interface EmailLinkRegisterStartRspAllOfData {
    /**
     * 
     * @type {string}
     * @memberof EmailLinkRegisterStartRspAllOfData
     */
    'emailLinkID': string;
}
/**
 * 
 * @export
 * @interface EmailLinkStatusReq
 */
export interface EmailLinkStatusReq {
    /**
     * 
     * @type {string}
     * @memberof EmailLinkStatusReq
     */
    'emailLinkID': string;
    /**
     * Unique ID of request, you can provide your own while making the request, if not the ID will be randomly generated on server side
     * @type {string}
     * @memberof EmailLinkStatusReq
     */
    'requestID'?: string;
}
/**
 * 
 * @export
 * @interface EmailLinkStatusRsp
 */
export interface EmailLinkStatusRsp {
    /**
     * HTTP status code of operation
     * @type {number}
     * @memberof EmailLinkStatusRsp
     */
    'httpStatusCode': number;
    /**
     * 
     * @type {string}
     * @memberof EmailLinkStatusRsp
     */
    'message': string;
    /**
     * 
     * @type {RequestData}
     * @memberof EmailLinkStatusRsp
     */
    'requestData': RequestData;
    /**
     * Runtime in seconds for this request
     * @type {number}
     * @memberof EmailLinkStatusRsp
     */
    'runtime': number;
    /**
     * 
     * @type {AuthenticationRsp}
     * @memberof EmailLinkStatusRsp
     */
    'data': AuthenticationRsp;
}
/**
 * 
 * @export
 * @interface EmptyReq
 */
export interface EmptyReq {
    /**
     * Unique ID of request, you can provide your own while making the request, if not the ID will be randomly generated on server side
     * @type {string}
     * @memberof EmptyReq
     */
    'requestID'?: string;
}
/**
 * 
 * @export
 * @interface ErrorRsp
 */
export interface ErrorRsp {
    /**
     * HTTP status code of operation
     * @type {number}
     * @memberof ErrorRsp
     */
    'httpStatusCode': number;
    /**
     * 
     * @type {string}
     * @memberof ErrorRsp
     */
    'message': string;
    /**
     * 
     * @type {RequestData}
     * @memberof ErrorRsp
     */
    'requestData': RequestData;
    /**
     * Runtime in seconds for this request
     * @type {number}
     * @memberof ErrorRsp
     */
    'runtime': number;
    /**
     * 
     * @type {ErrorRspAllOfError}
     * @memberof ErrorRsp
     */
    'error': ErrorRspAllOfError;
}
/**
 * 
 * @export
 * @interface ErrorRspAllOfError
 */
export interface ErrorRspAllOfError {
    /**
     * Type of error
     * @type {string}
     * @memberof ErrorRspAllOfError
     */
    'type': string;
    /**
     * Details of error
     * @type {string}
     * @memberof ErrorRspAllOfError
     */
    'details'?: string;
    /**
     * Validation errors per field
     * @type {Array<ErrorRspAllOfErrorValidation>}
     * @memberof ErrorRspAllOfError
     */
    'validation'?: Array<ErrorRspAllOfErrorValidation>;
    /**
     * Additional links to help understand the error
     * @type {Array<string>}
     * @memberof ErrorRspAllOfError
     */
    'links': Array<string>;
}
/**
 * 
 * @export
 * @interface ErrorRspAllOfErrorValidation
 */
export interface ErrorRspAllOfErrorValidation {
    /**
     * 
     * @type {string}
     * @memberof ErrorRspAllOfErrorValidation
     */
    'field': string;
    /**
     * 
     * @type {string}
     * @memberof ErrorRspAllOfErrorValidation
     */
    'message': string;
}
/**
 * User entry with emails and phone numbers
 * @export
 * @interface FullUser
 */
export interface FullUser {
    /**
     * ID of the user
     * @type {string}
     * @memberof FullUser
     */
    'ID': string;
    /**
     * 
     * @type {string}
     * @memberof FullUser
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FullUser
     */
    'fullName': string;
    /**
     * Timestamp of when the entity was created in yyyy-MM-dd\'T\'HH:mm:ss format
     * @type {string}
     * @memberof FullUser
     */
    'created': string;
    /**
     * Timestamp of when the entity was last updated in yyyy-MM-dd\'T\'HH:mm:ss format
     * @type {string}
     * @memberof FullUser
     */
    'updated': string;
    /**
     * 
     * @type {Status}
     * @memberof FullUser
     */
    'status': Status;
    /**
     * 
     * @type {Array<UserEmail>}
     * @memberof FullUser
     */
    'emails': Array<UserEmail>;
    /**
     * 
     * @type {Array<UserPhoneNumber>}
     * @memberof FullUser
     */
    'phoneNumbers': Array<UserPhoneNumber>;
}


/**
 * 
 * @export
 * @interface GenericRsp
 */
export interface GenericRsp {
    /**
     * HTTP status code of operation
     * @type {number}
     * @memberof GenericRsp
     */
    'httpStatusCode': number;
    /**
     * 
     * @type {string}
     * @memberof GenericRsp
     */
    'message': string;
    /**
     * 
     * @type {RequestData}
     * @memberof GenericRsp
     */
    'requestData': RequestData;
    /**
     * Runtime in seconds for this request
     * @type {number}
     * @memberof GenericRsp
     */
    'runtime': number;
}
/**
 * JSON Web Key
 * @export
 * @interface Jwk
 */
export interface Jwk {
    /**
     * The specific cryptographic algorithm used with the key
     * @type {string}
     * @memberof Jwk
     */
    'alg': string;
    /**
     * The family of cryptographic algorithms used with the key
     * @type {string}
     * @memberof Jwk
     */
    'kty': string;
    /**
     * How the key was meant to be used; sig represents the signature
     * @type {string}
     * @memberof Jwk
     */
    'use': string;
    /**
     * The modulus for the RSA public key
     * @type {string}
     * @memberof Jwk
     */
    'n': string;
    /**
     * The exponent for the RSA public key
     * @type {string}
     * @memberof Jwk
     */
    'e': string;
    /**
     * The unique identifier for the key
     * @type {string}
     * @memberof Jwk
     */
    'kid': string;
}
/**
 * Login Identifier type
 * @export
 * @enum {string}
 */

export const LoginIdentifierType = {
    Email: 'email',
    PhoneNumber: 'phone_number',
    Custom: 'custom'
} as const;

export type LoginIdentifierType = typeof LoginIdentifierType[keyof typeof LoginIdentifierType];


/**
 * 
 * @export
 * @interface LoginTokenReq
 */
export interface LoginTokenReq {
    /**
     * 
     * @type {string}
     * @memberof LoginTokenReq
     */
    'token': string;
    /**
     * Unique ID of request, you can provide your own while making the request, if not the ID will be randomly generated on server side
     * @type {string}
     * @memberof LoginTokenReq
     */
    'requestID'?: string;
}
/**
 * 
 * @export
 * @interface LoginTokenRsp
 */
export interface LoginTokenRsp {
    /**
     * HTTP status code of operation
     * @type {number}
     * @memberof LoginTokenRsp
     */
    'httpStatusCode': number;
    /**
     * 
     * @type {string}
     * @memberof LoginTokenRsp
     */
    'message': string;
    /**
     * 
     * @type {RequestData}
     * @memberof LoginTokenRsp
     */
    'requestData': RequestData;
    /**
     * Runtime in seconds for this request
     * @type {number}
     * @memberof LoginTokenRsp
     */
    'runtime': number;
    /**
     * 
     * @type {AuthenticationRsp}
     * @memberof LoginTokenRsp
     */
    'data': AuthenticationRsp;
}
/**
 * 
 * @export
 * @interface LogoutRsp
 */
export interface LogoutRsp {
    /**
     * HTTP status code of operation
     * @type {number}
     * @memberof LogoutRsp
     */
    'httpStatusCode': number;
    /**
     * 
     * @type {string}
     * @memberof LogoutRsp
     */
    'message': string;
    /**
     * 
     * @type {RequestData}
     * @memberof LogoutRsp
     */
    'requestData': RequestData;
    /**
     * Runtime in seconds for this request
     * @type {number}
     * @memberof LogoutRsp
     */
    'runtime': number;
    /**
     * 
     * @type {ShortSession}
     * @memberof LogoutRsp
     */
    'shortSession'?: ShortSession;
}
/**
 * 
 * @export
 * @interface MePassKeyRsp
 */
export interface MePassKeyRsp {
    /**
     * HTTP status code of operation
     * @type {number}
     * @memberof MePassKeyRsp
     */
    'httpStatusCode': number;
    /**
     * 
     * @type {string}
     * @memberof MePassKeyRsp
     */
    'message': string;
    /**
     * 
     * @type {RequestData}
     * @memberof MePassKeyRsp
     */
    'requestData': RequestData;
    /**
     * Runtime in seconds for this request
     * @type {number}
     * @memberof MePassKeyRsp
     */
    'runtime': number;
    /**
     * 
     * @type {PassKeyList}
     * @memberof MePassKeyRsp
     */
    'data': PassKeyList;
}
/**
 * 
 * @export
 * @interface MeRsp
 */
export interface MeRsp {
    /**
     * HTTP status code of operation
     * @type {number}
     * @memberof MeRsp
     */
    'httpStatusCode': number;
    /**
     * 
     * @type {string}
     * @memberof MeRsp
     */
    'message': string;
    /**
     * 
     * @type {RequestData}
     * @memberof MeRsp
     */
    'requestData': RequestData;
    /**
     * Runtime in seconds for this request
     * @type {number}
     * @memberof MeRsp
     */
    'runtime': number;
    /**
     * 
     * @type {FullUser}
     * @memberof MeRsp
     */
    'data': FullUser;
}
/**
 * 
 * @export
 * @interface Paging
 */
export interface Paging {
    /**
     * current page returned in response
     * @type {number}
     * @memberof Paging
     */
    'page': number;
    /**
     * total number of pages available
     * @type {number}
     * @memberof Paging
     */
    'totalPages': number;
    /**
     * total number of items available
     * @type {number}
     * @memberof Paging
     */
    'totalItems': number;
}
/**
 * 
 * @export
 * @interface PassKeyAppendFinishRsp
 */
export interface PassKeyAppendFinishRsp {
    /**
     * HTTP status code of operation
     * @type {number}
     * @memberof PassKeyAppendFinishRsp
     */
    'httpStatusCode': number;
    /**
     * 
     * @type {string}
     * @memberof PassKeyAppendFinishRsp
     */
    'message': string;
    /**
     * 
     * @type {RequestData}
     * @memberof PassKeyAppendFinishRsp
     */
    'requestData': RequestData;
    /**
     * Runtime in seconds for this request
     * @type {number}
     * @memberof PassKeyAppendFinishRsp
     */
    'runtime': number;
    /**
     * 
     * @type {PassKeyAppendFinishRspAllOfData}
     * @memberof PassKeyAppendFinishRsp
     */
    'data': PassKeyAppendFinishRspAllOfData;
}
/**
 * 
 * @export
 * @interface PassKeyAppendFinishRspAllOfData
 */
export interface PassKeyAppendFinishRspAllOfData {
    /**
     * 
     * @type {string}
     * @memberof PassKeyAppendFinishRspAllOfData
     */
    'redirectURL': string;
}
/**
 * 
 * @export
 * @interface PassKeyAssociateStartReq
 */
export interface PassKeyAssociateStartReq {
    /**
     * 
     * @type {string}
     * @memberof PassKeyAssociateStartReq
     */
    'associationToken': string;
    /**
     * Unique ID of request, you can provide your own while making the request, if not the ID will be randomly generated on server side
     * @type {string}
     * @memberof PassKeyAssociateStartReq
     */
    'requestID'?: string;
}
/**
 * 
 * @export
 * @interface PassKeyCredentialExistsReq
 */
export interface PassKeyCredentialExistsReq {
    /**
     * 
     * @type {string}
     * @memberof PassKeyCredentialExistsReq
     */
    'loginIdentifier': string;
    /**
     * 
     * @type {LoginIdentifierType}
     * @memberof PassKeyCredentialExistsReq
     */
    'loginIdentifierType': LoginIdentifierType;
    /**
     * Unique ID of request, you can provide your own while making the request, if not the ID will be randomly generated on server side
     * @type {string}
     * @memberof PassKeyCredentialExistsReq
     */
    'requestID'?: string;
}


/**
 * 
 * @export
 * @interface PassKeyCredentialExistsRsp
 */
export interface PassKeyCredentialExistsRsp {
    /**
     * HTTP status code of operation
     * @type {number}
     * @memberof PassKeyCredentialExistsRsp
     */
    'httpStatusCode': number;
    /**
     * 
     * @type {string}
     * @memberof PassKeyCredentialExistsRsp
     */
    'message': string;
    /**
     * 
     * @type {RequestData}
     * @memberof PassKeyCredentialExistsRsp
     */
    'requestData': RequestData;
    /**
     * Runtime in seconds for this request
     * @type {number}
     * @memberof PassKeyCredentialExistsRsp
     */
    'runtime': number;
    /**
     * 
     * @type {boolean}
     * @memberof PassKeyCredentialExistsRsp
     */
    'exists': boolean;
}
/**
 * 
 * @export
 * @interface PassKeyFinishReq
 */
export interface PassKeyFinishReq {
    /**
     * 
     * @type {string}
     * @memberof PassKeyFinishReq
     */
    'signedChallenge': string;
    /**
     * Unique ID of request, you can provide your own while making the request, if not the ID will be randomly generated on server side
     * @type {string}
     * @memberof PassKeyFinishReq
     */
    'requestID'?: string;
}
/**
 * 
 * @export
 * @interface PassKeyItem
 */
export interface PassKeyItem {
    /**
     * 
     * @type {string}
     * @memberof PassKeyItem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PassKeyItem
     */
    'aaguid': string;
    /**
     * 
     * @type {string}
     * @memberof PassKeyItem
     */
    'userAgent': string;
    /**
     * 
     * @type {string}
     * @memberof PassKeyItem
     */
    'attestationType': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PassKeyItem
     */
    'transport': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof PassKeyItem
     */
    'backupEligible': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PassKeyItem
     */
    'backupState': boolean;
    /**
     * Status
     * @type {string}
     * @memberof PassKeyItem
     */
    'status': PassKeyItemStatusEnum;
    /**
     * Timestamp of when the entity was created in yyyy-MM-dd\'T\'HH:mm:ss format
     * @type {string}
     * @memberof PassKeyItem
     */
    'created': string;
}

export const PassKeyItemStatusEnum = {
    Pending: 'pending',
    Active: 'active'
} as const;

export type PassKeyItemStatusEnum = typeof PassKeyItemStatusEnum[keyof typeof PassKeyItemStatusEnum];

/**
 * 
 * @export
 * @interface PassKeyList
 */
export interface PassKeyList {
    /**
     * 
     * @type {Array<PassKeyItem>}
     * @memberof PassKeyList
     */
    'passkeys': Array<PassKeyItem>;
    /**
     * 
     * @type {Paging}
     * @memberof PassKeyList
     */
    'paging'?: Paging;
}
/**
 * 
 * @export
 * @interface PassKeyLoginFinishRsp
 */
export interface PassKeyLoginFinishRsp {
    /**
     * HTTP status code of operation
     * @type {number}
     * @memberof PassKeyLoginFinishRsp
     */
    'httpStatusCode': number;
    /**
     * 
     * @type {string}
     * @memberof PassKeyLoginFinishRsp
     */
    'message': string;
    /**
     * 
     * @type {RequestData}
     * @memberof PassKeyLoginFinishRsp
     */
    'requestData': RequestData;
    /**
     * Runtime in seconds for this request
     * @type {number}
     * @memberof PassKeyLoginFinishRsp
     */
    'runtime': number;
    /**
     * 
     * @type {PassKeyLoginFinishRspAllOfData}
     * @memberof PassKeyLoginFinishRsp
     */
    'data': PassKeyLoginFinishRspAllOfData;
}
/**
 * 
 * @export
 * @interface PassKeyLoginFinishRspAllOfData
 */
export interface PassKeyLoginFinishRspAllOfData {
    /**
     * 
     * @type {string}
     * @memberof PassKeyLoginFinishRspAllOfData
     */
    'redirectURL': string;
    /**
     * Only given when using session v1
     * @type {string}
     * @memberof PassKeyLoginFinishRspAllOfData
     */
    'sessionToken'?: string;
    /**
     * Only given when project environment is dev
     * @type {string}
     * @memberof PassKeyLoginFinishRspAllOfData
     */
    'longSession'?: string;
    /**
     * 
     * @type {ShortSession}
     * @memberof PassKeyLoginFinishRspAllOfData
     */
    'shortSession'?: ShortSession;
    /**
     * 
     * @type {Array<AuthMethod>}
     * @memberof PassKeyLoginFinishRspAllOfData
     */
    'authMethods': Array<AuthMethod>;
    /**
     * 
     * @type {string}
     * @memberof PassKeyLoginFinishRspAllOfData
     */
    'username': string;
    /**
     * 
     * @type {boolean}
     * @memberof PassKeyLoginFinishRspAllOfData
     */
    'confirmedCredential': boolean;
}
/**
 * 
 * @export
 * @interface PassKeyLoginStartReq
 */
export interface PassKeyLoginStartReq {
    /**
     * Users login name
     * @type {string}
     * @memberof PassKeyLoginStartReq
     */
    'username': string;
    /**
     * Unique ID of request, you can provide your own while making the request, if not the ID will be randomly generated on server side
     * @type {string}
     * @memberof PassKeyLoginStartReq
     */
    'requestID'?: string;
}
/**
 * 
 * @export
 * @interface PassKeyMediationStartReq
 */
export interface PassKeyMediationStartReq {
    /**
     * Unique ID of request, you can provide your own while making the request, if not the ID will be randomly generated on server side
     * @type {string}
     * @memberof PassKeyMediationStartReq
     */
    'requestID'?: string;
    /**
     * 
     * @type {string}
     * @memberof PassKeyMediationStartReq
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface PassKeyMediationStartRsp
 */
export interface PassKeyMediationStartRsp {
    /**
     * HTTP status code of operation
     * @type {number}
     * @memberof PassKeyMediationStartRsp
     */
    'httpStatusCode': number;
    /**
     * 
     * @type {string}
     * @memberof PassKeyMediationStartRsp
     */
    'message': string;
    /**
     * 
     * @type {RequestData}
     * @memberof PassKeyMediationStartRsp
     */
    'requestData': RequestData;
    /**
     * Runtime in seconds for this request
     * @type {number}
     * @memberof PassKeyMediationStartRsp
     */
    'runtime': number;
    /**
     * 
     * @type {PassKeyMediationStartRspAllOfData}
     * @memberof PassKeyMediationStartRsp
     */
    'data': PassKeyMediationStartRspAllOfData;
}
/**
 * 
 * @export
 * @interface PassKeyMediationStartRspAllOfData
 */
export interface PassKeyMediationStartRspAllOfData {
    /**
     * Contains json payload data for start webauthn mediation challenge
     * @type {string}
     * @memberof PassKeyMediationStartRspAllOfData
     */
    'challenge': string;
}
/**
 * 
 * @export
 * @interface PassKeyRegisterFinishRsp
 */
export interface PassKeyRegisterFinishRsp {
    /**
     * HTTP status code of operation
     * @type {number}
     * @memberof PassKeyRegisterFinishRsp
     */
    'httpStatusCode': number;
    /**
     * 
     * @type {string}
     * @memberof PassKeyRegisterFinishRsp
     */
    'message': string;
    /**
     * 
     * @type {RequestData}
     * @memberof PassKeyRegisterFinishRsp
     */
    'requestData': RequestData;
    /**
     * Runtime in seconds for this request
     * @type {number}
     * @memberof PassKeyRegisterFinishRsp
     */
    'runtime': number;
    /**
     * 
     * @type {AuthenticationRsp}
     * @memberof PassKeyRegisterFinishRsp
     */
    'data': AuthenticationRsp;
}
/**
 * 
 * @export
 * @interface PassKeyRegisterStartReq
 */
export interface PassKeyRegisterStartReq {
    /**
     * Users login name
     * @type {string}
     * @memberof PassKeyRegisterStartReq
     */
    'username': string;
    /**
     * Users full name
     * @type {string}
     * @memberof PassKeyRegisterStartReq
     */
    'fullName'?: string;
    /**
     * Unique ID of request, you can provide your own while making the request, if not the ID will be randomly generated on server side
     * @type {string}
     * @memberof PassKeyRegisterStartReq
     */
    'requestID'?: string;
}
/**
 * 
 * @export
 * @interface PassKeyStartRsp
 */
export interface PassKeyStartRsp {
    /**
     * HTTP status code of operation
     * @type {number}
     * @memberof PassKeyStartRsp
     */
    'httpStatusCode': number;
    /**
     * 
     * @type {string}
     * @memberof PassKeyStartRsp
     */
    'message': string;
    /**
     * 
     * @type {RequestData}
     * @memberof PassKeyStartRsp
     */
    'requestData': RequestData;
    /**
     * Runtime in seconds for this request
     * @type {number}
     * @memberof PassKeyStartRsp
     */
    'runtime': number;
    /**
     * 
     * @type {PassKeyStartRspAllOfData}
     * @memberof PassKeyStartRsp
     */
    'data': PassKeyStartRspAllOfData;
}
/**
 * 
 * @export
 * @interface PassKeyStartRspAllOfData
 */
export interface PassKeyStartRspAllOfData {
    /**
     * Contains json payload data for start webauthn login challenge
     * @type {string}
     * @memberof PassKeyStartRspAllOfData
     */
    'challenge': string;
}
/**
 * 
 * @export
 * @interface PasswordVerifyReq
 */
export interface PasswordVerifyReq {
    /**
     * 
     * @type {string}
     * @memberof PasswordVerifyReq
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof PasswordVerifyReq
     */
    'password': string;
    /**
     * Unique ID of request, you can provide your own while making the request, if not the ID will be randomly generated on server side
     * @type {string}
     * @memberof PasswordVerifyReq
     */
    'requestID'?: string;
}
/**
 * 
 * @export
 * @interface PasswordVerifyRsp
 */
export interface PasswordVerifyRsp {
    /**
     * HTTP status code of operation
     * @type {number}
     * @memberof PasswordVerifyRsp
     */
    'httpStatusCode': number;
    /**
     * 
     * @type {string}
     * @memberof PasswordVerifyRsp
     */
    'message': string;
    /**
     * 
     * @type {RequestData}
     * @memberof PasswordVerifyRsp
     */
    'requestData': RequestData;
    /**
     * Runtime in seconds for this request
     * @type {number}
     * @memberof PasswordVerifyRsp
     */
    'runtime': number;
    /**
     * 
     * @type {AuthenticationRsp}
     * @memberof PasswordVerifyRsp
     */
    'data': AuthenticationRsp;
}
/**
 * 
 * @export
 * @interface ProjectConfigRsp
 */
export interface ProjectConfigRsp {
    /**
     * HTTP status code of operation
     * @type {number}
     * @memberof ProjectConfigRsp
     */
    'httpStatusCode': number;
    /**
     * 
     * @type {string}
     * @memberof ProjectConfigRsp
     */
    'message': string;
    /**
     * 
     * @type {RequestData}
     * @memberof ProjectConfigRsp
     */
    'requestData': RequestData;
    /**
     * Runtime in seconds for this request
     * @type {number}
     * @memberof ProjectConfigRsp
     */
    'runtime': number;
    /**
     * 
     * @type {ProjectConfigRspAllOfData}
     * @memberof ProjectConfigRsp
     */
    'data': ProjectConfigRspAllOfData;
}
/**
 * 
 * @export
 * @interface ProjectConfigRspAllOfData
 */
export interface ProjectConfigRspAllOfData {
    /**
     * 
     * @type {boolean}
     * @memberof ProjectConfigRspAllOfData
     */
    'allowUserRegistration': boolean;
    /**
     * 
     * @type {string}
     * @memberof ProjectConfigRspAllOfData
     */
    'passkeyAppendInterval': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectConfigRspAllOfData
     */
    'fallbackLanguage': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectConfigRspAllOfData
     */
    'autoDetectLanguage': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectConfigRspAllOfData
     */
    'userFullNameRequired': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectConfigRspAllOfData
     */
    'webComponentDebug': boolean;
    /**
     * 
     * @type {string}
     * @memberof ProjectConfigRspAllOfData
     */
    'environment': string;
}
/**
 * Data about the request itself, can be used for debugging
 * @export
 * @interface RequestData
 */
export interface RequestData {
    /**
     * Unique ID of request, you can provide your own while making the request, if not the ID will be randomly generated on server side
     * @type {string}
     * @memberof RequestData
     */
    'requestID': string;
    /**
     * Link to dashboard with details about request
     * @type {string}
     * @memberof RequestData
     */
    'link': string;
}
/**
 * 
 * @export
 * @interface SessionRefreshRsp
 */
export interface SessionRefreshRsp {
    /**
     * HTTP status code of operation
     * @type {number}
     * @memberof SessionRefreshRsp
     */
    'httpStatusCode': number;
    /**
     * 
     * @type {string}
     * @memberof SessionRefreshRsp
     */
    'message': string;
    /**
     * 
     * @type {RequestData}
     * @memberof SessionRefreshRsp
     */
    'requestData': RequestData;
    /**
     * Runtime in seconds for this request
     * @type {number}
     * @memberof SessionRefreshRsp
     */
    'runtime': number;
    /**
     * 
     * @type {string}
     * @memberof SessionRefreshRsp
     */
    'redirectURL': string;
    /**
     * Only given when using session v1
     * @type {string}
     * @memberof SessionRefreshRsp
     */
    'sessionToken'?: string;
    /**
     * Only given when project environment is dev
     * @type {string}
     * @memberof SessionRefreshRsp
     */
    'longSession'?: string;
    /**
     * 
     * @type {ShortSession}
     * @memberof SessionRefreshRsp
     */
    'shortSession'?: ShortSession;
    /**
     * 
     * @type {Array<AuthMethod>}
     * @memberof SessionRefreshRsp
     */
    'authMethods': Array<AuthMethod>;
}
/**
 * 
 * @export
 * @interface ShortSession
 */
export interface ShortSession {
    /**
     * 
     * @type {string}
     * @memberof ShortSession
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ShortSession
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof ShortSession
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof ShortSession
     */
    'path': string;
    /**
     * 
     * @type {boolean}
     * @memberof ShortSession
     */
    'secure': boolean;
    /**
     * 
     * @type {string}
     * @memberof ShortSession
     */
    'expires': string;
    /**
     * 
     * @type {string}
     * @memberof ShortSession
     */
    'sameSite': string;
}
/**
 * Generic status that can describe Corbado entities
 * @export
 * @enum {string}
 */

export const Status = {
    Active: 'active',
    Pending: 'pending',
    Deleted: 'deleted'
} as const;

export type Status = typeof Status[keyof typeof Status];


/**
 * User\'s email
 * @export
 * @interface UserEmail
 */
export interface UserEmail {
    /**
     * generic ID
     * @type {string}
     * @memberof UserEmail
     */
    'ID': string;
    /**
     * 
     * @type {string}
     * @memberof UserEmail
     */
    'email': string;
    /**
     * Timestamp of when the entity was created in yyyy-MM-dd\'T\'HH:mm:ss format
     * @type {string}
     * @memberof UserEmail
     */
    'created': string;
    /**
     * Timestamp of when the entity was last updated in yyyy-MM-dd\'T\'HH:mm:ss format
     * @type {string}
     * @memberof UserEmail
     */
    'updated': string;
    /**
     * 
     * @type {Status}
     * @memberof UserEmail
     */
    'status': Status;
}


/**
 * User\'s phone number
 * @export
 * @interface UserPhoneNumber
 */
export interface UserPhoneNumber {
    /**
     * generic ID
     * @type {string}
     * @memberof UserPhoneNumber
     */
    'ID': string;
    /**
     * 
     * @type {string}
     * @memberof UserPhoneNumber
     */
    'phoneNumber': string;
    /**
     * Timestamp of when the entity was created in yyyy-MM-dd\'T\'HH:mm:ss format
     * @type {string}
     * @memberof UserPhoneNumber
     */
    'created': string;
    /**
     * Timestamp of when the entity was last updated in yyyy-MM-dd\'T\'HH:mm:ss format
     * @type {string}
     * @memberof UserPhoneNumber
     */
    'updated': string;
    /**
     * 
     * @type {Status}
     * @memberof UserPhoneNumber
     */
    'status': Status;
}


/**
 * 
 * @export
 * @interface WellKnownJWKSListRsp
 */
export interface WellKnownJWKSListRsp {
    /**
     * 
     * @type {Array<Jwk>}
     * @memberof WellKnownJWKSListRsp
     */
    'keys': Array<Jwk>;
}

/**
 * AssetsApi - axios parameter creator
 * @export
 */
export const AssetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provides apple app site association
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appleAppSiteAssociation: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/.well-known/apple-app-site-association`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides asset links for android devices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetLinks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/.well-known/assetlinks.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetsApi - functional programming interface
 * @export
 */
export const AssetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Provides apple app site association
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appleAppSiteAssociation(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppleAppSiteAssociationRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appleAppSiteAssociation(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AssetsApi.appleAppSiteAssociation']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Provides asset links for android devices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetLinks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetLinks(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AssetsApi.assetLinks']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AssetsApi - factory interface
 * @export
 */
export const AssetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetsApiFp(configuration)
    return {
        /**
         * Provides apple app site association
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appleAppSiteAssociation(options?: any): AxiosPromise<AppleAppSiteAssociationRsp> {
            return localVarFp.appleAppSiteAssociation(options).then((request) => request(axios, basePath));
        },
        /**
         * Provides asset links for android devices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetLinks(options?: any): AxiosPromise<Array<AssetLink>> {
            return localVarFp.assetLinks(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
export class AssetsApi extends BaseAPI {
    /**
     * Provides apple app site association
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public appleAppSiteAssociation(options?: RawAxiosRequestConfig) {
        return AssetsApiFp(this.configuration).appleAppSiteAssociation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides asset links for android devices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public assetLinks(options?: RawAxiosRequestConfig) {
        return AssetsApiFp(this.configuration).assetLinks(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get project configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/projects/projectConfig`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get project configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectConfigRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectConfig(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectConfig']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * Get project configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectConfig(options?: any): AxiosPromise<ProjectConfigRsp> {
            return localVarFp.projectConfig(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * Get project configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectConfig(options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectConfig(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SessionsApi - axios parameter creator
 * @export
 */
export const SessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Performs session logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sessions/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs session refresh
         * @param {EmptyReq} emptyReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionRefresh: async (emptyReq: EmptyReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emptyReq' is not null or undefined
            assertParamExists('sessionRefresh', 'emptyReq', emptyReq)
            const localVarPath = `/v1/sessions/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emptyReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves well-known JWKS for Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wellKnownJWKSList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/.well-known/jwks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionsApi - functional programming interface
 * @export
 */
export const SessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Performs session logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogoutRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionLogout(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SessionsApi.sessionLogout']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Performs session refresh
         * @param {EmptyReq} emptyReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionRefresh(emptyReq: EmptyReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionRefreshRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionRefresh(emptyReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SessionsApi.sessionRefresh']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves well-known JWKS for Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async wellKnownJWKSList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WellKnownJWKSListRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.wellKnownJWKSList(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SessionsApi.wellKnownJWKSList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SessionsApi - factory interface
 * @export
 */
export const SessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionsApiFp(configuration)
    return {
        /**
         * Performs session logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionLogout(options?: any): AxiosPromise<LogoutRsp> {
            return localVarFp.sessionLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * Performs session refresh
         * @param {EmptyReq} emptyReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionRefresh(emptyReq: EmptyReq, options?: any): AxiosPromise<SessionRefreshRsp> {
            return localVarFp.sessionRefresh(emptyReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves well-known JWKS for Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wellKnownJWKSList(options?: any): AxiosPromise<WellKnownJWKSListRsp> {
            return localVarFp.wellKnownJWKSList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionsApi - object-oriented interface
 * @export
 * @class SessionsApi
 * @extends {BaseAPI}
 */
export class SessionsApi extends BaseAPI {
    /**
     * Performs session logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public sessionLogout(options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).sessionLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs session refresh
     * @param {EmptyReq} emptyReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public sessionRefresh(emptyReq: EmptyReq, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).sessionRefresh(emptyReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves well-known JWKS for Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public wellKnownJWKSList(options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).wellKnownJWKSList(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists user\'s available authentication methods
         * @param {AuthMethodsListReq} authMethodsListReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMethodsList: async (authMethodsListReq: AuthMethodsListReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authMethodsListReq' is not null or undefined
            assertParamExists('authMethodsList', 'authMethodsListReq', authMethodsListReq)
            const localVarPath = `/v1/users/authmethods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authMethodsListReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete current user\'s passkeys
         * @param {string} credentialID Credential ID from passkeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserPassKeyDelete: async (credentialID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentialID' is not null or undefined
            assertParamExists('currentUserPassKeyDelete', 'credentialID', credentialID)
            const localVarPath = `/v1/me/passkeys/{credentialID}`
                .replace(`{${"credentialID"}}`, encodeURIComponent(String(credentialID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets current user\'s passkeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserPassKeyGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/me/passkeys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs email OTP register confirm
         * @param {EmailCodeConfirmReq} emailCodeConfirmReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailCodeConfirm: async (emailCodeConfirmReq: EmailCodeConfirmReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailCodeConfirmReq' is not null or undefined
            assertParamExists('emailCodeConfirm', 'emailCodeConfirmReq', emailCodeConfirmReq)
            const localVarPath = `/v1/users/emailcodes/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailCodeConfirmReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs email OTP login start
         * @param {EmailCodeLoginStartReq} emailCodeLoginStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailCodeLoginStart: async (emailCodeLoginStartReq: EmailCodeLoginStartReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailCodeLoginStartReq' is not null or undefined
            assertParamExists('emailCodeLoginStart', 'emailCodeLoginStartReq', emailCodeLoginStartReq)
            const localVarPath = `/v1/users/emailcodes/login/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailCodeLoginStartReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs email OTP register start
         * @param {EmailCodeRegisterStartReq} emailCodeRegisterStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailCodeRegisterStart: async (emailCodeRegisterStartReq: EmailCodeRegisterStartReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailCodeRegisterStartReq' is not null or undefined
            assertParamExists('emailCodeRegisterStart', 'emailCodeRegisterStartReq', emailCodeRegisterStartReq)
            const localVarPath = `/v1/users/emailcodes/register/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailCodeRegisterStartReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs email OTP login status check
         * @param {EmailCodeStatusReq} emailCodeStatusReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailCodeStatus: async (emailCodeStatusReq: EmailCodeStatusReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailCodeStatusReq' is not null or undefined
            assertParamExists('emailCodeStatus', 'emailCodeStatusReq', emailCodeStatusReq)
            const localVarPath = `/v1/users/emailcodes/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailCodeStatusReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs email link register confirm
         * @param {EmailLinkConfirmReq} emailLinkConfirmReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailLinkConfirm: async (emailLinkConfirmReq: EmailLinkConfirmReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailLinkConfirmReq' is not null or undefined
            assertParamExists('emailLinkConfirm', 'emailLinkConfirmReq', emailLinkConfirmReq)
            const localVarPath = `/v1/users/emaillinks/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailLinkConfirmReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs email link login start
         * @param {EmailLinkLoginStartReq} emailLinkLoginStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailLinkLoginStart: async (emailLinkLoginStartReq: EmailLinkLoginStartReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailLinkLoginStartReq' is not null or undefined
            assertParamExists('emailLinkLoginStart', 'emailLinkLoginStartReq', emailLinkLoginStartReq)
            const localVarPath = `/v1/users/emaillinks/login/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailLinkLoginStartReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs email link register start
         * @param {EmailLinkRegisterStartReq} emailLinkRegisterStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailLinkRegisterStart: async (emailLinkRegisterStartReq: EmailLinkRegisterStartReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailLinkRegisterStartReq' is not null or undefined
            assertParamExists('emailLinkRegisterStart', 'emailLinkRegisterStartReq', emailLinkRegisterStartReq)
            const localVarPath = `/v1/users/emaillinks/register/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailLinkRegisterStartReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs email link login status check
         * @param {EmailLinkStatusReq} emailLinkStatusReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailLinkStatus: async (emailLinkStatusReq: EmailLinkStatusReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailLinkStatusReq' is not null or undefined
            assertParamExists('emailLinkStatus', 'emailLinkStatusReq', emailLinkStatusReq)
            const localVarPath = `/v1/users/emaillinks/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailLinkStatusReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs login for given token
         * @param {LoginTokenReq} loginTokenReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginToken: async (loginTokenReq: LoginTokenReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginTokenReq' is not null or undefined
            assertParamExists('loginToken', 'loginTokenReq', loginTokenReq)
            const localVarPath = `/v1/users/logintoken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginTokenReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs passkey append finish
         * @param {PassKeyFinishReq} passKeyFinishReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passKeyAppendFinish: async (passKeyFinishReq: PassKeyFinishReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passKeyFinishReq' is not null or undefined
            assertParamExists('passKeyAppendFinish', 'passKeyFinishReq', passKeyFinishReq)
            const localVarPath = `/v1/users/passkey/append/finish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passKeyFinishReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs passkey append start
         * @param {EmptyReq} emptyReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passKeyAppendStart: async (emptyReq: EmptyReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emptyReq' is not null or undefined
            assertParamExists('passKeyAppendStart', 'emptyReq', emptyReq)
            const localVarPath = `/v1/users/passkey/append/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emptyReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs passkey associate start
         * @param {PassKeyAssociateStartReq} passKeyAssociateStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passKeyAssociateStart: async (passKeyAssociateStartReq: PassKeyAssociateStartReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passKeyAssociateStartReq' is not null or undefined
            assertParamExists('passKeyAssociateStart', 'passKeyAssociateStartReq', passKeyAssociateStartReq)
            const localVarPath = `/v1/users/passkey/associate/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passKeyAssociateStartReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if active passkey credential exists for provided user and device
         * @param {PassKeyCredentialExistsReq} passKeyCredentialExistsReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passKeyCredentialExists: async (passKeyCredentialExistsReq: PassKeyCredentialExistsReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passKeyCredentialExistsReq' is not null or undefined
            assertParamExists('passKeyCredentialExists', 'passKeyCredentialExistsReq', passKeyCredentialExistsReq)
            const localVarPath = `/v1/users/device/passkey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passKeyCredentialExistsReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs passkey login finish
         * @param {PassKeyFinishReq} passKeyFinishReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passKeyLoginFinish: async (passKeyFinishReq: PassKeyFinishReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passKeyFinishReq' is not null or undefined
            assertParamExists('passKeyLoginFinish', 'passKeyFinishReq', passKeyFinishReq)
            const localVarPath = `/v1/users/passkey/login/finish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passKeyFinishReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs passkey login start
         * @param {PassKeyLoginStartReq} passKeyLoginStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passKeyLoginStart: async (passKeyLoginStartReq: PassKeyLoginStartReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passKeyLoginStartReq' is not null or undefined
            assertParamExists('passKeyLoginStart', 'passKeyLoginStartReq', passKeyLoginStartReq)
            const localVarPath = `/v1/users/passkey/login/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passKeyLoginStartReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs passkey mediation start
         * @param {PassKeyMediationStartReq} passKeyMediationStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passKeyMediationStart: async (passKeyMediationStartReq: PassKeyMediationStartReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passKeyMediationStartReq' is not null or undefined
            assertParamExists('passKeyMediationStart', 'passKeyMediationStartReq', passKeyMediationStartReq)
            const localVarPath = `/v1/users/passkey/mediation/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passKeyMediationStartReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs passkey register finish
         * @param {PassKeyFinishReq} passKeyFinishReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passKeyRegisterFinish: async (passKeyFinishReq: PassKeyFinishReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passKeyFinishReq' is not null or undefined
            assertParamExists('passKeyRegisterFinish', 'passKeyFinishReq', passKeyFinishReq)
            const localVarPath = `/v1/users/passkey/register/finish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passKeyFinishReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs passkey register start
         * @param {PassKeyRegisterStartReq} passKeyRegisterStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passKeyRegisterStart: async (passKeyRegisterStartReq: PassKeyRegisterStartReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passKeyRegisterStartReq' is not null or undefined
            assertParamExists('passKeyRegisterStart', 'passKeyRegisterStartReq', passKeyRegisterStartReq)
            const localVarPath = `/v1/users/passkey/register/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passKeyRegisterStartReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs password verify
         * @param {PasswordVerifyReq} passwordVerifyReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        password: async (passwordVerifyReq: PasswordVerifyReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordVerifyReq' is not null or undefined
            assertParamExists('password', 'passwordVerifyReq', passwordVerifyReq)
            const localVarPath = `/v1/users/password/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication projectID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Corbado-ProjectID", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordVerifyReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Lists user\'s available authentication methods
         * @param {AuthMethodsListReq} authMethodsListReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authMethodsList(authMethodsListReq: AuthMethodsListReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthMethodsListRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authMethodsList(authMethodsListReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.authMethodsList']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Gets current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentUserGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentUserGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.currentUserGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete current user\'s passkeys
         * @param {string} credentialID Credential ID from passkeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentUserPassKeyDelete(credentialID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentUserPassKeyDelete(credentialID, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.currentUserPassKeyDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Gets current user\'s passkeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentUserPassKeyGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MePassKeyRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentUserPassKeyGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.currentUserPassKeyGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Performs email OTP register confirm
         * @param {EmailCodeConfirmReq} emailCodeConfirmReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emailCodeConfirm(emailCodeConfirmReq: EmailCodeConfirmReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailCodeConfirmRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailCodeConfirm(emailCodeConfirmReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.emailCodeConfirm']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Performs email OTP login start
         * @param {EmailCodeLoginStartReq} emailCodeLoginStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emailCodeLoginStart(emailCodeLoginStartReq: EmailCodeLoginStartReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailCodeLoginStartRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailCodeLoginStart(emailCodeLoginStartReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.emailCodeLoginStart']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Performs email OTP register start
         * @param {EmailCodeRegisterStartReq} emailCodeRegisterStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emailCodeRegisterStart(emailCodeRegisterStartReq: EmailCodeRegisterStartReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailCodeRegisterStartRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailCodeRegisterStart(emailCodeRegisterStartReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.emailCodeRegisterStart']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Performs email OTP login status check
         * @param {EmailCodeStatusReq} emailCodeStatusReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emailCodeStatus(emailCodeStatusReq: EmailCodeStatusReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailCodeStatusRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailCodeStatus(emailCodeStatusReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.emailCodeStatus']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Performs email link register confirm
         * @param {EmailLinkConfirmReq} emailLinkConfirmReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emailLinkConfirm(emailLinkConfirmReq: EmailLinkConfirmReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailLinkConfirmRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailLinkConfirm(emailLinkConfirmReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.emailLinkConfirm']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Performs email link login start
         * @param {EmailLinkLoginStartReq} emailLinkLoginStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emailLinkLoginStart(emailLinkLoginStartReq: EmailLinkLoginStartReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailLinkLoginStartRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailLinkLoginStart(emailLinkLoginStartReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.emailLinkLoginStart']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Performs email link register start
         * @param {EmailLinkRegisterStartReq} emailLinkRegisterStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emailLinkRegisterStart(emailLinkRegisterStartReq: EmailLinkRegisterStartReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailLinkRegisterStartRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailLinkRegisterStart(emailLinkRegisterStartReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.emailLinkRegisterStart']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Performs email link login status check
         * @param {EmailLinkStatusReq} emailLinkStatusReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emailLinkStatus(emailLinkStatusReq: EmailLinkStatusReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailLinkStatusRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailLinkStatus(emailLinkStatusReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.emailLinkStatus']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Performs login for given token
         * @param {LoginTokenReq} loginTokenReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginToken(loginTokenReq: LoginTokenReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginTokenRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginToken(loginTokenReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.loginToken']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Performs passkey append finish
         * @param {PassKeyFinishReq} passKeyFinishReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passKeyAppendFinish(passKeyFinishReq: PassKeyFinishReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PassKeyAppendFinishRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passKeyAppendFinish(passKeyFinishReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.passKeyAppendFinish']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Performs passkey append start
         * @param {EmptyReq} emptyReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passKeyAppendStart(emptyReq: EmptyReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PassKeyStartRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passKeyAppendStart(emptyReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.passKeyAppendStart']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Performs passkey associate start
         * @param {PassKeyAssociateStartReq} passKeyAssociateStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passKeyAssociateStart(passKeyAssociateStartReq: PassKeyAssociateStartReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PassKeyStartRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passKeyAssociateStart(passKeyAssociateStartReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.passKeyAssociateStart']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Checks if active passkey credential exists for provided user and device
         * @param {PassKeyCredentialExistsReq} passKeyCredentialExistsReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passKeyCredentialExists(passKeyCredentialExistsReq: PassKeyCredentialExistsReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PassKeyCredentialExistsRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passKeyCredentialExists(passKeyCredentialExistsReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.passKeyCredentialExists']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Performs passkey login finish
         * @param {PassKeyFinishReq} passKeyFinishReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passKeyLoginFinish(passKeyFinishReq: PassKeyFinishReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PassKeyLoginFinishRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passKeyLoginFinish(passKeyFinishReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.passKeyLoginFinish']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Performs passkey login start
         * @param {PassKeyLoginStartReq} passKeyLoginStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passKeyLoginStart(passKeyLoginStartReq: PassKeyLoginStartReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PassKeyStartRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passKeyLoginStart(passKeyLoginStartReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.passKeyLoginStart']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Performs passkey mediation start
         * @param {PassKeyMediationStartReq} passKeyMediationStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passKeyMediationStart(passKeyMediationStartReq: PassKeyMediationStartReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PassKeyMediationStartRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passKeyMediationStart(passKeyMediationStartReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.passKeyMediationStart']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Performs passkey register finish
         * @param {PassKeyFinishReq} passKeyFinishReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passKeyRegisterFinish(passKeyFinishReq: PassKeyFinishReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PassKeyRegisterFinishRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passKeyRegisterFinish(passKeyFinishReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.passKeyRegisterFinish']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Performs passkey register start
         * @param {PassKeyRegisterStartReq} passKeyRegisterStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passKeyRegisterStart(passKeyRegisterStartReq: PassKeyRegisterStartReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PassKeyStartRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passKeyRegisterStart(passKeyRegisterStartReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.passKeyRegisterStart']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Performs password verify
         * @param {PasswordVerifyReq} passwordVerifyReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async password(passwordVerifyReq: PasswordVerifyReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordVerifyRsp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.password(passwordVerifyReq, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.password']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Lists user\'s available authentication methods
         * @param {AuthMethodsListReq} authMethodsListReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMethodsList(authMethodsListReq: AuthMethodsListReq, options?: any): AxiosPromise<AuthMethodsListRsp> {
            return localVarFp.authMethodsList(authMethodsListReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserGet(options?: any): AxiosPromise<MeRsp> {
            return localVarFp.currentUserGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete current user\'s passkeys
         * @param {string} credentialID Credential ID from passkeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserPassKeyDelete(credentialID: string, options?: any): AxiosPromise<GenericRsp> {
            return localVarFp.currentUserPassKeyDelete(credentialID, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets current user\'s passkeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserPassKeyGet(options?: any): AxiosPromise<MePassKeyRsp> {
            return localVarFp.currentUserPassKeyGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Performs email OTP register confirm
         * @param {EmailCodeConfirmReq} emailCodeConfirmReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailCodeConfirm(emailCodeConfirmReq: EmailCodeConfirmReq, options?: any): AxiosPromise<EmailCodeConfirmRsp> {
            return localVarFp.emailCodeConfirm(emailCodeConfirmReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs email OTP login start
         * @param {EmailCodeLoginStartReq} emailCodeLoginStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailCodeLoginStart(emailCodeLoginStartReq: EmailCodeLoginStartReq, options?: any): AxiosPromise<EmailCodeLoginStartRsp> {
            return localVarFp.emailCodeLoginStart(emailCodeLoginStartReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs email OTP register start
         * @param {EmailCodeRegisterStartReq} emailCodeRegisterStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailCodeRegisterStart(emailCodeRegisterStartReq: EmailCodeRegisterStartReq, options?: any): AxiosPromise<EmailCodeRegisterStartRsp> {
            return localVarFp.emailCodeRegisterStart(emailCodeRegisterStartReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs email OTP login status check
         * @param {EmailCodeStatusReq} emailCodeStatusReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailCodeStatus(emailCodeStatusReq: EmailCodeStatusReq, options?: any): AxiosPromise<EmailCodeStatusRsp> {
            return localVarFp.emailCodeStatus(emailCodeStatusReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs email link register confirm
         * @param {EmailLinkConfirmReq} emailLinkConfirmReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailLinkConfirm(emailLinkConfirmReq: EmailLinkConfirmReq, options?: any): AxiosPromise<EmailLinkConfirmRsp> {
            return localVarFp.emailLinkConfirm(emailLinkConfirmReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs email link login start
         * @param {EmailLinkLoginStartReq} emailLinkLoginStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailLinkLoginStart(emailLinkLoginStartReq: EmailLinkLoginStartReq, options?: any): AxiosPromise<EmailLinkLoginStartRsp> {
            return localVarFp.emailLinkLoginStart(emailLinkLoginStartReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs email link register start
         * @param {EmailLinkRegisterStartReq} emailLinkRegisterStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailLinkRegisterStart(emailLinkRegisterStartReq: EmailLinkRegisterStartReq, options?: any): AxiosPromise<EmailLinkRegisterStartRsp> {
            return localVarFp.emailLinkRegisterStart(emailLinkRegisterStartReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs email link login status check
         * @param {EmailLinkStatusReq} emailLinkStatusReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailLinkStatus(emailLinkStatusReq: EmailLinkStatusReq, options?: any): AxiosPromise<EmailLinkStatusRsp> {
            return localVarFp.emailLinkStatus(emailLinkStatusReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs login for given token
         * @param {LoginTokenReq} loginTokenReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginToken(loginTokenReq: LoginTokenReq, options?: any): AxiosPromise<LoginTokenRsp> {
            return localVarFp.loginToken(loginTokenReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs passkey append finish
         * @param {PassKeyFinishReq} passKeyFinishReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passKeyAppendFinish(passKeyFinishReq: PassKeyFinishReq, options?: any): AxiosPromise<PassKeyAppendFinishRsp> {
            return localVarFp.passKeyAppendFinish(passKeyFinishReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs passkey append start
         * @param {EmptyReq} emptyReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passKeyAppendStart(emptyReq: EmptyReq, options?: any): AxiosPromise<PassKeyStartRsp> {
            return localVarFp.passKeyAppendStart(emptyReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs passkey associate start
         * @param {PassKeyAssociateStartReq} passKeyAssociateStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passKeyAssociateStart(passKeyAssociateStartReq: PassKeyAssociateStartReq, options?: any): AxiosPromise<PassKeyStartRsp> {
            return localVarFp.passKeyAssociateStart(passKeyAssociateStartReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks if active passkey credential exists for provided user and device
         * @param {PassKeyCredentialExistsReq} passKeyCredentialExistsReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passKeyCredentialExists(passKeyCredentialExistsReq: PassKeyCredentialExistsReq, options?: any): AxiosPromise<PassKeyCredentialExistsRsp> {
            return localVarFp.passKeyCredentialExists(passKeyCredentialExistsReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs passkey login finish
         * @param {PassKeyFinishReq} passKeyFinishReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passKeyLoginFinish(passKeyFinishReq: PassKeyFinishReq, options?: any): AxiosPromise<PassKeyLoginFinishRsp> {
            return localVarFp.passKeyLoginFinish(passKeyFinishReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs passkey login start
         * @param {PassKeyLoginStartReq} passKeyLoginStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passKeyLoginStart(passKeyLoginStartReq: PassKeyLoginStartReq, options?: any): AxiosPromise<PassKeyStartRsp> {
            return localVarFp.passKeyLoginStart(passKeyLoginStartReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs passkey mediation start
         * @param {PassKeyMediationStartReq} passKeyMediationStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passKeyMediationStart(passKeyMediationStartReq: PassKeyMediationStartReq, options?: any): AxiosPromise<PassKeyMediationStartRsp> {
            return localVarFp.passKeyMediationStart(passKeyMediationStartReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs passkey register finish
         * @param {PassKeyFinishReq} passKeyFinishReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passKeyRegisterFinish(passKeyFinishReq: PassKeyFinishReq, options?: any): AxiosPromise<PassKeyRegisterFinishRsp> {
            return localVarFp.passKeyRegisterFinish(passKeyFinishReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs passkey register start
         * @param {PassKeyRegisterStartReq} passKeyRegisterStartReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passKeyRegisterStart(passKeyRegisterStartReq: PassKeyRegisterStartReq, options?: any): AxiosPromise<PassKeyStartRsp> {
            return localVarFp.passKeyRegisterStart(passKeyRegisterStartReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs password verify
         * @param {PasswordVerifyReq} passwordVerifyReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        password(passwordVerifyReq: PasswordVerifyReq, options?: any): AxiosPromise<PasswordVerifyRsp> {
            return localVarFp.password(passwordVerifyReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Lists user\'s available authentication methods
     * @param {AuthMethodsListReq} authMethodsListReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public authMethodsList(authMethodsListReq: AuthMethodsListReq, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).authMethodsList(authMethodsListReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public currentUserGet(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).currentUserGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete current user\'s passkeys
     * @param {string} credentialID Credential ID from passkeys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public currentUserPassKeyDelete(credentialID: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).currentUserPassKeyDelete(credentialID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets current user\'s passkeys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public currentUserPassKeyGet(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).currentUserPassKeyGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs email OTP register confirm
     * @param {EmailCodeConfirmReq} emailCodeConfirmReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public emailCodeConfirm(emailCodeConfirmReq: EmailCodeConfirmReq, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).emailCodeConfirm(emailCodeConfirmReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs email OTP login start
     * @param {EmailCodeLoginStartReq} emailCodeLoginStartReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public emailCodeLoginStart(emailCodeLoginStartReq: EmailCodeLoginStartReq, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).emailCodeLoginStart(emailCodeLoginStartReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs email OTP register start
     * @param {EmailCodeRegisterStartReq} emailCodeRegisterStartReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public emailCodeRegisterStart(emailCodeRegisterStartReq: EmailCodeRegisterStartReq, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).emailCodeRegisterStart(emailCodeRegisterStartReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs email OTP login status check
     * @param {EmailCodeStatusReq} emailCodeStatusReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public emailCodeStatus(emailCodeStatusReq: EmailCodeStatusReq, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).emailCodeStatus(emailCodeStatusReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs email link register confirm
     * @param {EmailLinkConfirmReq} emailLinkConfirmReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public emailLinkConfirm(emailLinkConfirmReq: EmailLinkConfirmReq, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).emailLinkConfirm(emailLinkConfirmReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs email link login start
     * @param {EmailLinkLoginStartReq} emailLinkLoginStartReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public emailLinkLoginStart(emailLinkLoginStartReq: EmailLinkLoginStartReq, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).emailLinkLoginStart(emailLinkLoginStartReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs email link register start
     * @param {EmailLinkRegisterStartReq} emailLinkRegisterStartReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public emailLinkRegisterStart(emailLinkRegisterStartReq: EmailLinkRegisterStartReq, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).emailLinkRegisterStart(emailLinkRegisterStartReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs email link login status check
     * @param {EmailLinkStatusReq} emailLinkStatusReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public emailLinkStatus(emailLinkStatusReq: EmailLinkStatusReq, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).emailLinkStatus(emailLinkStatusReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs login for given token
     * @param {LoginTokenReq} loginTokenReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public loginToken(loginTokenReq: LoginTokenReq, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).loginToken(loginTokenReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs passkey append finish
     * @param {PassKeyFinishReq} passKeyFinishReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public passKeyAppendFinish(passKeyFinishReq: PassKeyFinishReq, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).passKeyAppendFinish(passKeyFinishReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs passkey append start
     * @param {EmptyReq} emptyReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public passKeyAppendStart(emptyReq: EmptyReq, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).passKeyAppendStart(emptyReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs passkey associate start
     * @param {PassKeyAssociateStartReq} passKeyAssociateStartReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public passKeyAssociateStart(passKeyAssociateStartReq: PassKeyAssociateStartReq, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).passKeyAssociateStart(passKeyAssociateStartReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks if active passkey credential exists for provided user and device
     * @param {PassKeyCredentialExistsReq} passKeyCredentialExistsReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public passKeyCredentialExists(passKeyCredentialExistsReq: PassKeyCredentialExistsReq, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).passKeyCredentialExists(passKeyCredentialExistsReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs passkey login finish
     * @param {PassKeyFinishReq} passKeyFinishReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public passKeyLoginFinish(passKeyFinishReq: PassKeyFinishReq, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).passKeyLoginFinish(passKeyFinishReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs passkey login start
     * @param {PassKeyLoginStartReq} passKeyLoginStartReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public passKeyLoginStart(passKeyLoginStartReq: PassKeyLoginStartReq, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).passKeyLoginStart(passKeyLoginStartReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs passkey mediation start
     * @param {PassKeyMediationStartReq} passKeyMediationStartReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public passKeyMediationStart(passKeyMediationStartReq: PassKeyMediationStartReq, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).passKeyMediationStart(passKeyMediationStartReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs passkey register finish
     * @param {PassKeyFinishReq} passKeyFinishReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public passKeyRegisterFinish(passKeyFinishReq: PassKeyFinishReq, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).passKeyRegisterFinish(passKeyFinishReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs passkey register start
     * @param {PassKeyRegisterStartReq} passKeyRegisterStartReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public passKeyRegisterStart(passKeyRegisterStartReq: PassKeyRegisterStartReq, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).passKeyRegisterStart(passKeyRegisterStartReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs password verify
     * @param {PasswordVerifyReq} passwordVerifyReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public password(passwordVerifyReq: PasswordVerifyReq, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).password(passwordVerifyReq, options).then((request) => request(this.axios, this.basePath));
    }
}



